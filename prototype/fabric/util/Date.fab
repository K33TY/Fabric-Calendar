package prototype.fabric.util;

import fabric.runtime.Runtime;
//import fabil.ast.FabricArrayInit;
//import fabric.lang.*;
//import fabric.util.List;

/**
 * This class is a simple utility class for representing and comparing dates.
 * It is not intended to replace or duplicate the functionality of
 * java.util.Date.
 * It provides precision only to the minute.
 * It is immutable.
 * It provides no way to get the current time.
 */
public class Date[label L, principal p] {

    private int{L} year;
    private int{L} month;
    private int{L} day;
    private int{L} hour;
    private int{L} minute;

	// Special list structures because of issues with polyglot no able to instantiate arrays with values
	// Originally this was compiling and allowing to add values when it was non static and label L
    public StringList[L]{L}  monthNames;

    public StringList[L]{L}  daysOfWeek;

    public StringList[L]{L}  shortDaysOfWeek;

    public StringList[L]{L}  shortMonthNames; //[{⊤←⊤}]{⊤←⊤}

    public IntList[L]{L}     maxDaysInMonth;

	  //---------------//
	 //  Constructors //
	//---------------//

	// Set date to current time
    public Date()
    where   L ⊑ {this},
    	    {this} ⊑ L
    {
        // TODO: originally final principal p = PrincipalUtil.nullPrincipal(); and date not requiring principal for construction...
        this.year = Runtime[p].currentYear();
        this.month = Runtime[p].currentMonth();
        this.day = Runtime[p].currentDayOfMonth();
        this.hour = Runtime[p].currentHour();
        this.minute = Runtime[p].currentMinute();

        setConstants();
    }

    public Date{L}(int{L; this} pYear, int{L; this} pMonth, int{L; this} pDay, int{L; this} pHour, int{L; this} pMinute)
    throws  (IllegalArgumentException{pYear; pMonth; pDay; pHour; pMinute})
    {
        this.year = pYear;
        this.month = pMonth;
        this.day = pDay;
        this.hour = pHour;
        this.minute = pMinute;
        checkDateValid(pYear, pMonth, pDay, pHour, pMinute);

        setConstants();
    }

    public Date{L}(int{L; this} pYear, int{L; this} pMonth, int{L; this} pDay)
    throws (IllegalArgumentException{pYear; pMonth; pDay})
    {
        this(pYear, pMonth, pDay, 0, 0);
    }

    public Date{L}(int{L; this} pYear, String{L; this} pMonth, int{L; this} pDay, int{L; this} pHour, int{L; this} pMinute)
    throws (IllegalArgumentException{pYear; pMonth; pDay; pHour; pMinute})
    where   L ⊑ {this},
        	{this} ⊑ L
    {
        this.year = pYear;
        this.day = pDay;
        this.hour = pHour;
        this.minute = pMinute;
        int theMonth = 0;
        for (int i = 1; i <= 12; i++)
        {
            try
            {
                if (monthNames.get(i).equalsIgnoreCase(pMonth) || shortMonthNames.get(i).equalsIgnoreCase(pMonth))
                {
                    theMonth = i;
                    break;
                }
            }
            catch(Exception impossible) {  }
        }
        if (theMonth == 0)
        {
            throw new IllegalArgumentException("Invalid month: " + pMonth);
        }
        this.month = theMonth;
        checkDateValid(pYear, theMonth, pDay, pHour, pMinute);

        setConstants();
    }

    public Date{L}(int{L; this} pYear, String{L; this} pMonth, int{L; this} pDay)
    throws (IllegalArgumentException{pYear; pMonth; pDay})
    where   L ⊑ {this},
            {this} ⊑ L
    {
        this(pYear, pMonth, pDay, 0, 0);
    }

	  //-----------------------------//
	 //  Constructor Helper Methods //
	//-----------------------------//

	//  Cannot instantiate arrays with values so doing this stupid thing
    public void setConstants{L}()
    {
        // Month Names
        monthNames.add("NOT A VALID MONTH");
        monthNames.add("January");
		monthNames.add("February");
		monthNames.add("March");
		monthNames.add("April");
		monthNames.add("May");
		monthNames.add("June");
		monthNames.add("July");
		monthNames.add("August");
		monthNames.add("September");
		monthNames.add("October");
		monthNames.add("November");
		monthNames.add("December");

		// Days of week
		daysOfWeek.add("Sunday");
		daysOfWeek.add("Monday");
		daysOfWeek.add("Tuesday");
		daysOfWeek.add("Wednesday");
		daysOfWeek.add("Thursday");
		daysOfWeek.add("Friday");
		daysOfWeek.add("Saturday");
		daysOfWeek.add("Sunday");

		// Short month names
		shortMonthNames.add("NOT A VALID MONTH");
		shortMonthNames.add("Jan");
		shortMonthNames.add("Feb");
		shortMonthNames.add("Mar");
		shortMonthNames.add("Apr");
		shortMonthNames.add("May");
		shortMonthNames.add("Jun");
		shortMonthNames.add("Jul");
		shortMonthNames.add("Aug");
		shortMonthNames.add("Sep");
		shortMonthNames.add("Oct");
		shortMonthNames.add("Nov");
		shortMonthNames.add("Dec");

		// Short days of week
		shortDaysOfWeek.add("Sun");
		shortDaysOfWeek.add("Mon");
		shortDaysOfWeek.add("Tue");
		shortDaysOfWeek.add("Wed");
		shortDaysOfWeek.add("Thu");
		shortDaysOfWeek.add("Fri");
		shortDaysOfWeek.add("Sat");
		shortDaysOfWeek.add("Sun");

		// Maximum days in month
		maxDaysInMonth.add(-1);
		maxDaysInMonth.add(31);
		maxDaysInMonth.add(29);
		maxDaysInMonth.add(31);
		maxDaysInMonth.add(30);
		maxDaysInMonth.add(31);
        maxDaysInMonth.add(30);
        maxDaysInMonth.add(31);
        maxDaysInMonth.add(31);
        maxDaysInMonth.add(30);
        maxDaysInMonth.add(31);
        maxDaysInMonth.add(30);
        maxDaysInMonth.add(31);
    }

    // why is this method orginally static if called from a object that is being instantiated?
    public int{L} daysInMonth{L}(int month, int year)
    where   {month; year} ⊑ L
    {
        if (month < 1 || month > 12) return -1;
        try
        {
            if (month == 2)
            {
                return isLeapYear(year)?29:28;
            }
            return maxDaysInMonth.get(month);
        }
        catch (Exception impossible)
        {
            return -1;
        }
    }

    /**
     * Determine if the given year is a leap years. A year is a leap year
     * if it is divisible by 4, unless it is the first year of a century
     * (i.e. is divisible by 100), except for every fourth century.
     */
    public boolean{pYear} isLeapYear(int pYear)
    {
        return (pYear % 4 == 0 && (pYear % 100 != 0 || pYear % 400 == 0));
    }

	// why is this method orginally static if called from a object that is being instantiated?
    private void checkDateValid{L}(int{L; this} pYear, int{L; this} pMonth, int{L; this} pDay, int{L; this} pHour, int{L; this} pMinute)
    throws  (IllegalArgumentException{pYear; pMonth; pDay; pHour; pMinute})
    {
        if (pMonth < 1 || pMonth > 12)
        {
            throw new IllegalArgumentException("Invalid month: " + pMonth);
        }
        /*try {
            if (pDay < 1 || pDay > daysInMonth(pMonth, pYear))
            {
                throw new IllegalArgumentException(monthNames[pMonth] + " " +
                      pYear + " has " + daysInMonth(pMonth, pYear) + " days.");
            }
        }
        catch(ArrayIndexOutOfBoundsException impossible) { }
        catch(NullPointerException impossible) { }*/
        if (pHour < 0 || pHour > 23)
        {
            throw new IllegalArgumentException("Invalid hour: " + pHour);
        }
        if (pMinute < 0 || pMinute > 59)
        {
            throw new IllegalArgumentException("Invalid minute: " + pMinute);
        }
    }

    /** TODO: DOES NOT BUILD YET!!!!!!!!
     * At the moment, assume that the string is in the format YYYY/MM/DD hh:mm
     * or DD-MM-YYYY hh:mm
     */
    /*public static Date[{*lbl}, p]{*lbl} valueOf{*lbl}(label{*lbl} lbl, String{*lbl} d, principal p)
    throws (IllegalArgumentException{*lbl})
    where   lbl ⊑ {*lbl},
            {*lbl} ⊑ lbl
    {
        if (d == null)
        {
            throw new IllegalArgumentException("null string");
        }
        int yearStart = 0;
        int yearEnd = 4;
        int monthStart = 5;
        int monthEnd = 7;
        int dayStart = 8;
        int dayEnd = 10;
        int hourStart = -1;
        int hourEnd = -1;
        int minStart = -1;
        int minEnd = -1;
        int i = d.indexOf('-', 0);
        if (i > 0) {
            // date is of the form dd-mm-yyyy
            dayStart=0;
            dayEnd = i;
            monthStart = i + 1;
            int j = d.indexOf('-', monthStart);
            if (j > 0)
            {
                monthEnd = j;
                yearStart = j + 1;
                yearEnd = yearStart + 4;
            }
            else
            {
                throw new IllegalArgumentException("invalid string: format should be DD-MM-YYYY");
            }
        }
        if (yearEnd != d.length())
        {
            // the time is included
            hourStart = yearEnd + 1;
            hourEnd = d.indexOf(':', hourStart);
            minStart = hourEnd+1;
            minEnd = minStart+2;
        }
        else if (d.length() != 10)
        {
            throw new IllegalArgumentException("invalid string: format should be DD-MM-YYYY [hh:mm]" + d.length());
        }

        try
        {
            int year = Integer.parseInt(d.substring(yearStart,yearEnd));
            int month = Integer.parseInt(d.substring(monthStart,monthEnd));
            int day = Integer.parseInt(d.substring(dayStart,dayEnd));
            int hour = 0;
            int min = 0;
            if (hourStart > 0)
            {
                hour = Integer.parseInt(d.substring(hourStart,hourEnd));
            }
            if (minStart > 0)
            {
                min = Integer.parseInt(d.substring(minStart,minEnd));
            }
            return new Date[{*lbl}, p](year, month, day, hour, min);
        }
        catch (NumberFormatException e)
        {
            throw new IllegalArgumentException("invalid string: format should be DD-MM-YYYY [hh:mm]");
        }
        catch (StringIndexOutOfBoundsException impossible)
        {
            return null;
        }
    }*/

	// Why is this static originally?
	// What is the purpose of this method anyways? why are we making a "lenient date" with new label?
    public Date[{*lbl}, p]{*lbl} lenientDate{L}(label lbl, int{*lbl} year, int{*lbl} month, int{*lbl} day, principal p)
    where   caller(p),
            //authority(p),
            //endorse({*lbl}),
			{month} ⊑ {L},
            {p→;p←} ⊑ {*lbl},
            {*lbl} ⊑ {p→;p←},
            {*lbl} ⊑ {L},
            {L} ⊑ {*lbl},
            {*lbl} ⊑ {⊤→this.store$},  // TODO: What does this mean?
            {⊤←this.store$} ⊑ {*lbl}   // TODO: and this?
    {
         // issue with daysInMonth()
        int y = year;
        int m = month;
        int d = day;
        try {
            while (m > 12 || m < 1 || d < 1 || d > daysInMonth(m, y))
            {
                while (m > 12)
                {
                    m -= 12; y++;
                }
                while (m < 1)
                {
                    m += 12; y--;
                }
                // m is now between 1 and 12 inclusive
                if (d > daysInMonth(m, y))
                {
                    d -= daysInMonth(m, y); m++;
                }
                if (d < 1)
                {
                    d += daysInMonth((m+10)%12+1, y); m--;
                }
            }
            //label newlbl = {L}⊔{*lbl};//idea
            //return new Date[newlbl, p](y, m, d);
            return new Date[{*lbl}, p](y, m, d);
        }
        catch (IllegalArgumentException impossible) { }
        return null;
    }

    // Why is this static originally?
    public Date[lbl, p] lenientDate(label lbl, int{*lbl} year, int{*lbl} month, int{*lbl} day, int{*lbl} hour, int{*lbl} minute, principal p )
    {
    /*    int y = year;
        int m = month;
        int d = day;
        int h = hour;
        int min = minute;

        while (min > 59)
        {
            min -= 60; h++;
        }
        while (min < 0)
        {
            min += 60; h--;
        }
        while (h > 23)
        {
            h -= 24; d++;
        }
        while (h < 0)
        {
            h += 24; d--;
        }

        try {
            while (m > 12 || m < 1 || d < 1 || d > daysInMonth(m, y)) {
                while (m > 12) {
                    m -= 12; y++;
                }
                while (m < 1) {
                    m += 12; y--;
                }
                // m is now between 1 and 12 inclusive
                if (d > daysInMonth(m, y)) {
                    d -= daysInMonth(m, y); m++;
                }
                if (d < 1) {
                    d += daysInMonth((m+10)%12+1, y); m--;
                }
            }
            return new Date[lbl](y, m, d, h, min);
        }
        catch (IllegalArgumentException impossible) { }*/
        return null;
    }


      //-------------------//
     //      Getters      //
    //-------------------//

    public String{L} getMonthName{L}()
    {
        try
        {
            return monthNames.get(this.month);
        }
        catch(Exception impossible) { }
        return "impossible!";
    }

    public String{L} getShortMonthName{L}()
    {
        try
        {
            return shortMonthNames.get(this.month);
        }
        catch(Exception impossible) { }
        return "impossible!";
    }

    public String{L} getDayOfWeekName{L}()
    {
        try
        {
            return daysOfWeek.get(this.getDayOfWeek());
        }
		catch(Exception impossible) { }
        return "impossible!";
    }

    public String{L} getShortDayOfWeekName{L}()
    {
        try {
            return shortDaysOfWeek.get(this.getDayOfWeek());
        }
        catch(Exception impossible) { }
        return "impossible!";
    }

	// Why is implemented twice?
    /*public String{L} getDayOfWeek{L}()
    {
	    try
	    {
	        return daysOfWeek.get(this.day);
	    }
	    catch(Exception impossible) { }
        return "impossible!";
	}*/

    public int{L} getYear()     { return this.year;     }
    public int{L} getMonth()    { return this.month;    }
    public int{L} getDay()      { return this.day;      }
    public int{L} getHour()     { return this.hour;     }
    public int{L} getMinute()   { return this.minute;    }
    public int{L} getDayOfWeek() {
        // Jan 1 1900 was a monday, so its index is 1.
        // add the number of days since then, and take mod 7
        // could be a negative number, so add seven to be safe...
        int thisD = this.daysAfterJan_1_1900(this.year, this.month, this.day);
        return ((thisD % 7) + 8) % 7;
    }

    private int daysAfterJan_1_1900(int year, int month, int day)
    {
        int y = year;
        int m = month;
        int d = day;
        int count = 0;

        while (y - 400 > 1900) {
            count += DAYS_IN_400_YEARS;
            y -= 400;
        }
        while (y + 400 < 1900) {
            count -= DAYS_IN_400_YEARS;
            y += 400;
        }

        while (y > 1900) {
            count += isLeapYear(--y)?366:365;
        }
        while (y < 1900) {
            count -= isLeapYear(++y)?366:365;
        }
        // now y == 1900
        while (m > 1) {
            //count += daysInMonth(--m, y); //TODO: FIX ME
            /* Error:

				build-calendar:
				    [apply] /Users/Elizabeth/Desktop/MEng_Project/Calendar-Fabric/prototype/fabric/util/Date.fab:449:
				    [apply]     Unsatisfiable constraint
				    [apply]     	general constraint:
				    [apply]     		actual_arg_1 ⊑ formal_arg_1
				    [apply]     	in this context:
				    [apply]     		{month ⊔ caller_pc ⊔ ⊥→⊥; ⊤←} ⊑ L
				    [apply]     	cannot satisfy equation:
				    [apply]     		{month ⊔ caller_pc} ⊑ L
				    [apply]     	in environment:
				    [apply]     		{this} ⊑ {L ⊔ ⊥→⊥; ⊥←⊥}
				    [apply]     		L ⊑ {⊤→this.store$}
				    [apply]     		L ⊑ {⊤→this.store$}
				    [apply]     		{⊤←this.store$} ⊑ L
				    [apply]     		{this} ⊑ {caller_pc}
				    [apply]     		[]
				    [apply]
				    [apply]     Label Descriptions
				    [apply]     ------------------
				    [apply]      - actual_arg_1 = the label of the 1st actual argument
				    [apply]      - actual_arg_1 = {month ⊔ caller_pc ⊔ ⊥→⊥; ⊤←}
				    [apply]      - formal_arg_1 = the upper bound of the formal argument month
				    [apply]      - formal_arg_1 = L
				    [apply]      - month = polymorphic label of formal argument month of method
				    [apply]     daysAfterJan_1_1900 (bounded above by {⊤→})
				    [apply]      - caller_pc = pc label
				    [apply]      - L = label parameter L of class prototype.fabric.util.Date
				    [apply]      - this = label of the special variable "this" in
				    [apply]     prototype.fabric.util.Date[label L, principal p]
				    [apply]
				    [apply]     The label of the actual argument, actual_arg_1, is more restrictive than
				    [apply]     the label of the formal argument, formal_arg_1.
				    [apply]             count += daysInMonth(--m, y);
				    [apply]                                  ^-^
				    [apply]
				    [apply] 1 error.
				    [apply] null
            */
        }
        count += d-1;
        return count;
    }
    private final int{⊤←⊤} DAYS_IN_400_YEARS = 146097;


    public boolean{L; when} before{L}(Date[L, p] when)
    where   {when} ⊑ {L}
    {
        Date[L, p] that = when;
        if (that == null)
        {
            return false;
        }
        return (this.year < that.year) ||
            (this.year == that.year && this.month < that.month) ||
            (this.year == that.year && this.month == that.month && this.day < that.day) ||
            (this.year == that.year && this.month == that.month && this.day == that.day && this.hour < that.hour) ||
            (this.year == that.year && this.month == that.month && this.day == that.day && this.hour == that.hour && this.minute < that.minute);
    }

    public boolean{L; when} after{L}(Date[L, p] when)
    where   {when} ⊑ {L}
    {
        Date[L, p] that = when;
        if (that == null)
        {
            return false;
        }
        return (this.year > that.year) ||
            (this.year == that.year && this.month > that.month) ||
            (this.year == that.year && this.month == that.month && this.day > that.day) ||
            (this.year == that.year && this.month == that.month && this.day == that.day && this.hour > that.hour) ||
            (this.year == that.year && this.month == that.month && this.day == that.day && this.hour == that.hour && this.minute > that.minute);
    }

    /**
     * Return number of days that this is before when. Will return a negative
     * number if this is after when.
     */
    public int{L; when} daysBefore{L}(Date[L, p] when)
    where   {when} ⊑ {L},
		    {this} ⊑ {L}
    {
        if (when == null) return 0;
        Date[L, p] w = when;
        Date[L, p] t = this;
        int whenD = w.daysAfterJan_1_1900(when.year, when.month, when.day);
        int thisD = t.daysAfterJan_1_1900(this.year, this.month, this.day);

        return whenD - thisD;
    }

      //-------------------//
     //    Formatting     //
    //-------------------//

    public String{L} toString{L}()
    {
        return this.toLongString();
    }

    public String{L} toLongString{L}()
    {
        String min = "" + minute;
        if (min.length() < 2) min = "0" + min;
        String h = "" + hour;
        if (h.length() < 2) h = "0" + h;

        return day + " " + getMonthName() + " " + year + " " + h + ":" + min;
    }

    public String{L} toShortString()
    {
        String min = "" + minute;
        if (min.length() < 2) min = "0" + min;
        String h = "" + hour;
        if (h.length() < 2) h = "0" + h;
        return day + "-" + month + "-" + year + " " + h + ":" + min;
    }

    public int{L} hashCode()
    {
        return (year) ^
            (month * 256) ^
            (day * 1024) ^
            (hour * 13) ^
            minute;
    }

      //----------------------------//
     //  Functional Style Methods  //
    //----------------------------//

    public Date[L, p]{L} year{L}(int{this} year):{L; this}
    throws IllegalArgumentException
    {
        return new Date[L, p](year, this.month, this.day, this.hour, this.minute);
    }

    public Date[L, p]{L} month{L}(int{this} month):{L; this}
    throws IllegalArgumentException
    {
        return new Date[L, p](this.year, month, this.day, this.hour, this.minute);
    }

    public Date[L, p]{L} day{L}(int{this} day):{L; this}
    throws IllegalArgumentException
    {
        return new Date[L, p](this.year, this.month, day, this.hour, this.minute);
    }

    public Date[L, p]{L} hour{L}(int{this} hour):{L; this}
    throws IllegalArgumentException
    {
        return new Date[L, p](this.year, this.month, this.day, hour, this.minute);
    }

    public Date[L, p]{L} minute{L}(int{this} minute):{L; this}
    throws IllegalArgumentException
    {
        return new Date[L, p](this.year, this.month, this.day, this.hour, minute);
    }

    ////    public Date[L]{L} addYear(int{L} yearDelta):{L; this} {
    ////        return lenientDate(L, this.year + yearDelta, this.month, this.day);
    ////    }
    ////    public Date[L]{L} addMonth(int{L} monthDelta):{L; this} {
    ////        return lenientDate(L, this.year, this.month + monthDelta, this.day);
    ////    }
    ////    public Date[L]{L} addDay(int{L} dayDelta):{L; this} {
    ////        return lenientDate(L, this.year, this.month, this.day + dayDelta);
    ////    }
    //    public static Date[lb]{*lb; lb; date; delta} addYear{*lb}(label lb, Date[lb]{*lb} date, int{*lb} delta) {
    //        if (date == null) return null;
    //        return Date[lb].lenientDate(lb, date.getYear() + delta, date.getMonth(), date.getDay(), date.getHour(), date.getMinute());
    //    }
    //    public static Date[lb]{*lb; lb; date; delta} addMonth{*lb}(label lb, Date[lb]{*lb} date, int{*lb} delta) {
    //        if (date == null) return null;
    //        return Date[lb].lenientDate(lb, date.getYear(), date.getMonth() + delta, date.getDay(), date.getHour(), date.getMinute());
    //    }
    //    /**
    //     * Adds a positive or negative number of months to the date. If smartUpdate is true, then
    //     * the returned date is guranteed to be at most one calendar month away; if smartUpdate is false, this is
    //     * not guaranteed. An example where behavior is different adding one month to October 31. There is no November 31, so with
    //     * smartUpdate false, the date returned would be Dec 1; with smartUpdate true, the date returned would be November 30.
    //     * Another example, March 30 minus one month would be either March 1 or March 2 if smartUpdate false (depending on leap years), and
    //     * either Feb 28 or Feb 29 if smartUpdate true (depending on leap years).
    //     */
    //    public static Date[lb]{*lb; lb; date; delta} addMonth{*lb}(label{*lb} lb, Date[lb]{*lb} date, int{*lb} delta, boolean{*lb} smartUpdate) {
    //        if (date == null) return null;
    //        Date[lb] d = Date[lb].lenientDate(lb, date.getYear(), date.getMonth() + delta, date.getDay(), date.getHour(), date.getMinute());
    //        if (smartUpdate) {
    //            int newMonth = date.getMonth() + delta;
    //            newMonth = newMonth % 12; // make the new month in the correct range
    //            if (newMonth <= 0) newMonth += 12;
    //            while (d != null && newMonth != d.getMonth()) {
    //                d = addDay(lb, d, delta<0?1:-1);
    //            }
    //        }
    //        return d;
    //    }
    //    public static Date[lb]{*lb; lb; date; delta} addDay{*lb}(label lb, Date[lb]{*lb} date, int{*lb} delta) {
    //        if (date == null) return null;
    //        return Date[lb].lenientDate(lb, date.getYear(), date.getMonth(), date.getDay() + delta, date.getHour(), date.getMinute());
    //    }
    //    public static Date[lb]{*lb; lb; date; delta} addHour{*lb}(label lb, Date[lb]{*lb} date, int{*lb} delta) {
    //        if (date == null) return null;
    //        return Date[lb].lenientDate(lb, date.getYear(), date.getMonth(), date.getDay(), date.getHour() + delta, date.getMinute());
    //    }
    //    public static Date[lb]{*lb; lb; date; delta} addMinute{*lb}(label lb, Date[lb]{*lb} date, int{*lb} delta) {
    //        if (date == null) return null;
    //        return Date[lb].lenientDate(lb, date.getYear(), date.getMonth(), date.getDay(), date.getHour(), date.getMinute()+ delta);
    //    }

    //    /* THIS DOES NOT COMPILE:
    //    //TODO: IS THIS A NECESSARY PART OF DATE?
    //    public boolean{L;o} equals(IDComparable[L] o) {
    //        return equals(L, o);
    //    }
    //    public boolean{L;*lbl;lbl;o} equals(label lbl, IDComparable[lbl] o) {
    //        if (o == null || !(o instanceof Date[lbl])) {
    //            return false;
    //        }
    //        Date[lbl] that = (Date[lbl])o;
    //        return this.year == that.year &&
    //            this.month == that.month &&
    //            this.day == that.day &&
    //            this.hour == that.hour&&
    //            this.minute == that.minute;
    //
    //    }*/
    //
}
