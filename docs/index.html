<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fabric: How to Create a Fabric Application</title>

    <link rel="stylesheet" href="stylesheet.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
    <script src="js/scripts.js"></script>

    <script type="text/javascript">
        $(document).ready(function() {
            hideAll();
            $('#intro').show();
            $('#features').show();
            $('#store').show();
            $('#calendar').show();
            $('#references').show();
        });

        function hideAll() {
            $('#intro').hide();
            $('#features').hide();
            $('#store').hide();
            $('#worker').hide();
            $('#calendar').hide();
            $('#references').hide();
        };

        $(function() {
            $('#showIntro').click(function() {
                hideAll();
                $('#intro').show();
                return false;
            });

            $('#showFeatures').click(function() {
                hideAll();
                $('#features').show();
                return false;
            });

            $('#showStore').click(function() {
                hideAll();
                $('#store').show();
                return false;
            });

            $('#showWorker').click(function() {
                hideAll();
                $('#worker').show();
                return false;
            });

            $('#showCalendar').click(function() {
                hideAll();
                $('#calendar').show();
                return false;
            });

            $('#showReferences').click(function() {
                hideAll();
                $('#references').show();
                return false;
            });
        });
    </script>
</head>
<body>
<div id="header">
    <h1>Fabric: How to Create a Fabric Application</h1>
</div>

<div id="main">
    <div id="navPane">
        <div id="nav">
            <!--ANCHORS TO CONTENT-->
            <a href="#" class="main-link" id="showIntro">Introduction</a><br />

            <a href="#" class="main-link" id="showFeatures">Language Features</a><br />

            <a href="#" class="main-link" id="showStore">Store</a><br />
            <ul class="sub-link">
                <li>
                    Persistence
                </li>
                <li>
                    Implementation Example
                </li>
            </ul>

            <a href="#" class="main-link" id="showWorker">Worker</a><br />

            <a href="#" class="main-link" id="showCalendar">Calendar Example</a><br />

            <a href="#" class="main-link" id="showReferences">References</a>
        </div>
    </div>

    <div id="contentPane">
        <div id="content">
            <div id="intro">
                <h2>Introduction</h2>

                This site's main purpose will be to walk a new user through the different steps of creating a basic
                Fabric application. <br /> <br />

                This is not meant to be a replacement for the <a href="https://www.cs.cornell.edu/projects/fabric/manual/0.3.0/html/">
                Fabric manual</a>, but supplementary material of a more hands-on nature.<br />
            </div>

            <div id="features">
                <h2>Language Features</h2>
                Fabric is a language designed to enforce information flow policies during both compile and runtime across
                multiple domains which have could have mutual distrust. The language is designed to follow the same trust
                assumption as what is used for the internet: "trust nobody." Hence, it does not care which nodes enter the
                "Fabric" since any node can delegate authority or access control to specific nodes (principals). This idea
                is highly useful for current issues in Cross Domain Assurance, allowing for the sharing of valuable data,
                both computations and information, in a way which strongly enforces both confidentiality and integrity
                expectations. <br /><br />

                There any many valuable and novel features that exist within the language which sets it apart from both
                prior implementations of distributed systems, which might focus heavily on either persistence or information
                flow. A list of such features, some of which will be described in more detail, are as follows:<br />

                <ul>
                    <li>persistent storage</li>
                    <li>data shipping</li>
                    <li>function shipping (remote method calls)</li>
                    <li>access control labels on objects</li>
                    <li>capability to grant authority to principal over classes and/or specific methods</li>
                    <li>capability to delegate authority from one principal to another</li>
                    <li>optimistic atomic transactions allowing for rollback when encountering various issues</li>
                    <li>sophisticated transaction bookkeeping and management</li>
                </ul><br />
            </div>

            <div id="store">
                <h2>Store</h2>
                The storage nodes in Fabric are designed to be persistent storage for Fabric objects, and these nodes allow
                for the provision of these objects to both worker nodes and the dissemination layer. <br /><br />

                The store should group objects by similar security policies. This allows the store to easily perform the
                data shipping necessary to cache objects at any requesting node who has the associated access control labels.

                <h3>Persistence</h3>
                Storage nodes can be started with terminal commands, or with executables assuming the developer has
                created these shell scripts. Upon starting the store node, the node will first attempt to read in any
                storage files on the machine with the expected store name. If it exists, it will load the persistent data
                from there. Otherwise, it will simply create a new store from scratch. When a storage node is properly
                shutdown, without using a kill process command, then it will make sure to write all of its data in serialized
                form to its associated storage file. (Supposing the attacker has access to the store, could he read the
                store's information for himself?)

                <h3>Implementation Example</h3>
                Here, we explore a simple implementation of using a Fabric store:<br />
            </div>

            <div id="worker">
                <h2>Worker</h2>
            </div>

            <div id="calendar">
                <h2>Calendar Example</h2>

                A calendar application was written in Fabric's precursor language, Jif. This prior calendar, based on
                Jif's language capabilities, was not distributed. Porting the calendar to the Fabric language meant
                requiring an overhaul to the architecture. <br /><br />

                The original calendar implemented a mySQL database to achieve persistence, and setting up the database
                was a requirement for running the application. The actions for the calendar required accessing the database
                by authorized principals (calendar users). However, in the Fabric language, there is an object implemented
                with the intention of serving as a persistent database. This object, the store, follows the many new
                distributed design decisions implemented in the Fabric language. <br /><br />

                Now, instead of implementing a database, and using database calls to achieve the functionality in the
                calendar, we simply need to ensure that a storage node is running somewhere with the persistent features
                required by the calendar. In essence, this storage node acts as the top principal with the greatest label
                {&#8868;→&#8868;;&#8868;←&#8868;}, allowing the storage to perform all actions on any calendar in an
                active user session. <br /><br />

                A worker node is spun up for any individual user wanting to access the calendar. This follows the Fabric
                language premise which states that objects do not "instantiate" but rather join the overall "Fabric."
                The worker node, therefore should allow a user to either join the calendar (a future wanted capability)
                or authenticate a session if they have already joined the calendar previously. With both of these actions,
                we are able to use Fabric's idea of remote calls, accessing the storage node by invoking appropriate
                methods at the store. <br /><br />

                Adding a user is a feature that would be nice to implement, and may become another method with the least
                label that the store allows. Of course, the store will check that the username is valid and not already
                in use, especially considering the username is operating as a user-id, or key, for access to all of the
                user's objects within their calendar. At this point, we shall first hard-code this functionality until
                the other portions of the calendar are implemented.<br /><br />

                In the case of authentication, we do not care about the latency for authentication happening over the
                wire since this would be no different if we had to do the same task via a SQL database access. At this
                point, the worker node is completely untrusted, having the least label {&#8869;→&#8869;;&#8869;←&#8869;}.
                The store allows a singular remote call to operate with this security label, namely a method which allows
                the store to receive input from the user at the given worker node. If the user provides a valid username
                and password combination, then the store will delegate the confidentiality and integrity permissions of
                that user to the active session represented by the worker node. Furthermore, it will use the Fabric's
                language feature of data shipping, and cache all objects at the worker node relating to the authenticated
                user.  <br /><br />

                <h2>A brief overview of objects within the Fabric Calendar application</h2>

                <h3>Events Objects:</h3>
                OwnerEvents and AttendeeEvents essentially have the same fields. Maybe it would be possible to allow these
                objects to cast to each other with the new policy enforced. For example, OwnerEvent can always cast to
                AttendeeEvent, but AttendeeEvent can only cast to OwnerEvent if P = uid?<br /><br />

                <strong>OwnerEvent</strong>
                Given the policy label {P→;P←}
                <ul>
                    <li>event id</li>
                    <li>owner uid</li>
                    <li>event name</li>
                    <li>event starting time</li>
                    <li>event ending time</li>
                    <li>event note</li>
                    <li>list of attendees (allowed to view but not access any field in the event)</li>
                    <li>list of viewers (only allowed to view time of event but no other field, instead see "busy")</li>
                </ul><br />

                <strong>AttendeeEvent</strong>
                Given the policy label {P→}
                <ul>
                    <li>event id</li>
                    <li>owner uid</li>
                    <li>event name</li>
                    <li>event starting time</li>
                    <li>event ending time</li>
                    <li>event note</li>
                    <li>list of attendees (allowed to view but not access any field in the event)</li>
                    <li>list of viewers (only allowed to view time of event but no other field, instead see "busy")</li>
                </ul><br />

                <strong>ViewerEvent</strong>
                <ul>
                    <li>event id</li>
                    <li>event name = "busy"</li>
                    <li>event starting time</li>
                    <li>event ending time</li>
                </ul>

                <h3>Principals:</h3>

                <strong>Store</strong><br />
                A persistent storage node representing what in the Jif implementation CalRootEP principal. This Calendar
                Root Principal has the greatest privilege {&#8868;→&#8868;;&#8868;←&#8868;} <br /><br />
                <ul>
                    <li>ownedEvents is a hash mapping uid to a hashmap of oid→OwnerEvent objects that uid owns</li>
                    <li>attendeeEvents is a hash mapping uid to a hashmap of oid→AttendeeEvent objects that uid may attend</li>
                    <li>viewerEvents is a hash mapping uid to a hashmap of oid→ViewerEvent objects that uid may view</li>
                    <li>a list of calendar users</li>
                    <li>a list of logged on users</li>
                    <li>a list of accessed objects (this becomes necessary if we are going to later let more than one
                        user edit an event)</li>
                    <li>method to add an event: <br />
                        <ul>
                            <li>append OwnedEvent to ownedEvents.get(uid).put(e.oid, e)</li>
                            <li>for each user in the list of attendees create AttendeeEvent
                                and append to attendeeEvents.get(uid).put(e.oid, e)</li>
                            <li>for each user in the list of viewers create ViewerEvent
                                and append to viewerEvents.get(uid).put(e.oid, e)</li>
                        </ul>
                    </li>
                    <li>method to edit an event: <br />
                        <ul>
                            <li>update OwnedEvent in ownedEvents.get(uid)</li>
                            <li>for each user in the list of attendees update AttendeeEvent in attendeeEvents.get(uid).get(oid),
                            and check if user is in logged on users. If so, push event to user. If push fails more than
                            x retries, assume that user left without logging off, so simply remove them from logged on
                            users list</li>
                            <li>for each user in the list of viewers update ViewerEvent in viewerEvents.get(uid).get(oid),
                            and check if user is in logged on users. If so, push event to user. If push fails more than
                            x retries, assume that user left without logging off, so simply remove them from logged on
                            users list</li>
                        </ul>
                    </li>
                    <li>method to authenticate a user: <br />
                        <ul>
                            <li>check if uid exists, if not return null</li>
                            <li>check if pw matches for uid, if so delegate rights of uid to worker and ship all objects
                            associated with this user</li>
                        </ul>
                    </li>
                    <li>method to log a user off of the system: <br />
                        <ul>
                            <li>remove user from logged on users list</li>
                            <li>later implementation could be multithreaded to check for user inactivity and automatically
                            log off users</li>
                        </ul>
                    </li>
                    <li>method give full names of active calendar users to an authenticated user: this allows user to know
                    who they can add to their events</li>
                </ul>

                <strong>Worker</strong><br />
                A temporal "session" node representing what in the Jif implementation was essentially the Userv package
                and the CalServEP principal. It starts off with the least label {&#8869;→&#8869;;&#8869;←&#8869;}, and
                has the possibility to acquire a labeling for a new user or for an existing user assuming authentication.<br /><br />

                <em>Prior to authentication:</em><br />
                <ul>
                    <li>user = bottom principal &#8869;</li>
                    <li>list of events owned = null</li>
                    <li>list of events attending = null</li>
                    <li>list of viewable events = null</li>
                    <li>method to authenticate: remote call <font color="#006400">auth(input userID, input pw)@store</font>
                    and date instantiation</li>
                    <li>method to add user: remote call <font color="#006400">add(input userID, input pw)@store</font>
                        and date instantiation</li>
                </ul>
                (I seem to remember that remote calls are protected by SSL?)<br /><br />

                <em>Upon authentication:</em><br />
                <ul>
                    <li>user = P (self)</li>
                    <li>list of events P owns</li>
                    <li>list of events P is attending</li>
                    <li>list of events P may view</li>
                    <li>method to add an event: <font color="#006400">addEvent(Event e)@store</font></li>
                    <li>method to edit an event: <font color="#006400">editEvent(Event e)@store</font></li>
                    <li>method to log off: <font color="#006400">logOff()@store</font></li>
                    <li>method to full names of other calendar users: <font color="#006400">getUsers()@store</font></li>
                </ul>

                <h3>Other Objects:</h3>
                <strong>Date</strong><br />
                This object should not require any special consideration for confidentiality policy of the assumption that
                the user can view their time and date themselves. Because we use user specific system time to instantiate
                only their calendar for a session, we are assured that no data can be leaked by this allowance. <br /><br />

                The Calendar Root Principal has some understanding of this object, but never needs to instantiate this for
                itself as it will not need to print any dates to a servlet.<br /><br />

                <strong>Servlet Related Code</strong><br />
                Because the worker only accesses data that they are allowed to read and write, the calendar that they can
                see is instantiated on these objects. This removes the need to do any downgrading in the instantiation
                and updating of the calendar client-side.<br /><br />

                <h2>This implementation requires the following considerations:</h2>
                <ol>
                    <li>
                        How will the authenticated user acquire all calendar objects that they own or have permission to
                        access or view?
                    </li>
                    <li>
                        How will the user prepare and commit new calendar event objects or edit existing events? Furthermore,
                        how will the store propagate these changes on commit, especially to any other active user?
                    </li>
                    <li>
                        (This was not existing in the prior calendar implementation, but would be fun if time permits.)
                        What issues exist during multiple user accesses to the same calendar objects, assuming we allow
                        attendees to write to the object (perhaps to leave an event)? Namely, how will the store implement
                        the transaction map so that Fabric's sense of optimistic transaction holds?
                    </li>
                    <li>
                        How does the calendar root allow a user to acquire the name of other users of the calendar? Do we
                        suppose that an authenticated user should have privilege to access this? What are any issues if we
                        further allow them to access the username which is effectively the current uid for the current
                        implementation?
                    </li>
                    <li>
                        Finally, most importantly, how will security labels properly enforce the desired purposes?
                    </li>
                </ol>


                <!---TODO>
                <h3>Consideration One</h3>
                To properly account for the acquisition of a user's objects and delegation of principal rights, the store's
                overall contents must be considered.
                <TODO-----><br />

            </div>

            <div id="references">
                <h2>References</h2>
                <dl class="citelist">
                    <dt><a class="anchor" id="CITEREF_mobile-fabric-2012"></a>[1]</dt>
                    <dd><p class="startdd">Owen Arden, Michael&#160;D. George, Jed Liu, K.&#160;Vikram, Aslan Askarov, and Andrew&#160;C. Myers. <a href="http://www.cs.cornell.edu/andru/papers/mobile.html">Sharing mobile code securely with information flow control</a>. In <em>Proc. IEEE 2012 Symposium on Security and Privacy</em>, pages 191&ndash;205, San Francisco, CA, USA, May 2012. Software release at <a href="http://www.cs.cornell.edu/projects/fabric/">http://www.cs.cornell.edu/projects/fabric/</a>.</p>
                        <p class="enddd"></p>
                    </dd>
                    <dt><a class="anchor" id="CITEREF_oo7"></a>[2]</dt>
                    <dd><p class="startdd">Michael&#160;J. Carey, David&#160;J. DeWitt, and Jeffrey&#160;F. Naughton. The OO7 benchmark. In <em>Proc. ACM SIGMOD 1993 International Conference on Management of Data</em>, pages 12&ndash;21, Washington, DC, USA, May 1993.</p>
                        <p class="enddd"></p>
                    </dd>
                    <dt><a class="anchor" id="CITEREF_sif2007"></a>[3]</dt>
                    <dd><p class="startdd">Stephen Chong, K.&#160;Vikram, and Andrew&#160;C. Myers. <a href="http://www.cs.cornell.edu/andru/papers/sif.pdf">SIF: Enforcing confidentiality and integrity in web applications</a>. In <em>Proc. 16th USENIX Security Symposium</em>, pages 1&ndash;16, Boston, MA, USA, August 2007. See <a href="http://www.cs.cornell.edu/jif/sif/">http://www.cs.cornell.edu/jif/sif/</a>.</p>
                        <p class="enddd"></p>
                    </dd>
                    <dt><a class="anchor" id="CITEREF_fabric2009"></a>[4]</dt>
                    <dd><p class="startdd">Jed Liu, Michael&#160;D. George, K.&#160;Vikram, Xin Qi, Lucas Waye, and Andrew&#160;C. Myers. <a href="http://www.cs.cornell.edu/andru/papers/fabric-sosp09.html">Fabric: A platform for secure distributed computation and storage</a>. In <em>Proc. 22nd ACM Symposium on Operating System Principles (SOSP)</em>, pages 321&ndash;334, Big Sky, MT, USA, October 2009. Software release at <a href="http://www.cs.cornell.edu/projects/fabric/">http://www.cs.cornell.edu/projects/fabric/</a>.</p>
                        <p class="enddd"></p>
                    </dd>
                    <dt><a class="anchor" id="CITEREF_jif-popl1999"></a>[5]</dt>
                    <dd><p class="startdd">Andrew&#160;C. Myers. <a href="http://www.cs.cornell.edu/andru/papers/popl99/myers-popl99.ps.gz">JFlow: Practical mostly-static information flow control</a>. pages 228&ndash;241, San Antonio, TX, USA, January 1999. Software release at <a href="http://www.cs.cornell.edu/jif/">http://www.cs.cornell.edu/jif/</a>.</p>
                        <p class="enddd"></p>
                    </dd>
                </dl>
            </div>
        </div>
        </div>
    </div>
</div>

<div id="footer">

</div>

</body>
</html>