<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fabric: How to Create a Fabric Application</title>

    <link rel="stylesheet" href="stylesheet.css">
	<link rel="stylesheet" href="highlight/styles/liz.css">
	
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
    <script type="text/javascript" src="js/scripts.js"></script>
	<script type="text/javascript" src="highlight/highlight.pack.js"></script>
    <script type="text/javascript">hljs.initHighlightingOnLoad();</script>


    <script type="text/javascript">
        $(document).ready(function() {
            $('pre code').each(function(i, block) {
                hljs.highlightBlock(block);
            });
        });

		$(function() {
			var nav = $( '#nav' );
			
			// loop through each content section so we can use its ID
			$( '.content-section' ).each( function() {
				var div = $( this );
				var divID = div.attr( 'id' );
				
				// loop through all of the content headers and dynamically generate
				// their IDs, anchors, and navbar links
				div.children( '.content-header' ).each( function() {
					var header = $( this );
					var headerID = 'section-' + divID;
					
					// make this header clickable with an anchor tag
					header.attr( 'id', headerID );
					header.wrapInner( '<a href="#' + headerID + '" >' );
					
					// dynamically create a new link so we can add it to the navbar
					var navDiv = $( '<div>' );
					var navLink = $( '<a>' );
					navLink.text( header.text() );
					navLink.attr({ href: '#' + headerID, class: 'main-link' });
					navDiv.append( navLink );
					
					// check if this section has subsections to link to
					var subsections = div.children( '.content-subsection' );
					if ( subsections.length > 0 ) {
						var ul = $( '<ul class="sub-link">' );
						
						subsections.each( function() {
							var sub = $( this );
							var subText = sub.attr( 'content-link' ) || sub.text();
							var subID = headerID + '-' + subText.toLowerCase();
							
							// make this subheader clickable with an anchor tag
							sub.attr( 'id', subID );
							sub.wrapInner( '<a href="#' + subID + '" >' );
							
							// dynamically add a new sublink to the parent UL
							var navSubLink = $( '<a>' );
							navSubLink.text( subText );
							navSubLink.attr({ href: '#' + subID, class: 'content-sublink' });
							
							var li = $( '<li>' );
							li.append( navSubLink );
							ul.append( li );
						});
						// add the list of subsections to the new section div in the navbar
						navDiv.append( ul );
					}
					// add the new section div in the navbar
					nav.append( navDiv );
				});
			})
			
			// scroll to newly created anchor now
            if (location.hash) {
                var requested_hash = location.hash.slice(1);
                location.hash = '';
                location.hash = requested_hash;
            }
		});
    </script>
</head>
<body>
<div id="header">
	<div style="width: 100%;">
		<h1>Fabric: How to Create a Fabric Application</h1>
	</div>
	<div>
		<img id="seal" width="64px" height="64px" src="imgs/cornell_seal.svg"/>
	</div>
</div>

<div id="main">
    <div id="navPane">
        <div id="nav"></div>
    </div>

<!--======================================|  INTRO  |========================================-->
    <div id="contentPane">
        <div id="content">
            <div id="intro" class="content-section">
                <h2 class="content-header">Introduction</h2>

                This site's main purpose will be to walk a new user through the different steps of creating a basic
                Fabric application. <br /> <br />

                This is not meant to be a replacement for the <a href="https://www.cs.cornell.edu/projects/fabric/manual/0.3.0/html/">
                Fabric manual</a>, but supplementary material of a more hands-on nature.<br />
            </div>

<!--======================================|  FEATURES  |========================================-->
            <div id="features" class="content-section">
                <h2 class="content-header">Language Features</h2>
                Fabric is a language designed to enforce information flow policies during both compile and runtime across
                multiple domains which have could have mutual distrust. The language is designed to follow the same trust
                assumption as what is used for the internet: "trust nobody." Hence, it does not care which nodes enter the
                "Fabric" since any node can delegate authority or access control to specific nodes (principals). This idea
                is highly useful for current issues in Cross Domain Assurance, allowing for the sharing of valuable data,
                both computations and information, in a way which strongly enforces both confidentiality and integrity
                expectations. <br /><br />

                There any many valuable and novel features that exist within the language which sets it apart from both
                prior implementations of distributed systems, which might focus heavily on either persistence or information
                flow. A list of such features, some of which will be described in more detail, are as follows:<br />

                <ul>
                    <li>persistent storage</li>
                    <li>data shipping</li>
                    <li>function shipping (remote method calls)</li>
                    <li>access control labels on objects</li>
                    <li>capability to grant authority to principal over classes and/or specific methods</li>
                    <li>capability to delegate authority from one principal to another</li>
                    <li>optimistic atomic transactions allowing for rollback when encountering various issues</li>
                    <li>sophisticated transaction bookkeeping and management</li>
                </ul><br />

                <img src="imgs/arch.svg"/>
                <div class="caption">
                    Src: <a href="https://github.com/apl-cornell/fabric/tree/master/doc/posters/cucs-50-years">
                            APL Cornell Github: Fabric posters
                         </a>
                </div>
            </div>

<!--======================================|  COMPILING  |========================================-->
            <div id="compiling" class="content-section">
                <h2 class="content-header">Compilation Structure</h2>
                Fabric classes are written as <font color="#bf0a00">.fab </font> files, and these
                files enforce information-flow policies. The Fabric compiler, <font color="#bf0a00">fabc </font>,
                compiles Fabric classes first into the Fabric Intermediate Language, and further compiles the code using the
                <font color="#bf0a00">filc </font> compiler into Java so that the JVM can recognize the code. <br /><br />

                <img src="imgs/fabcfilc.svg"/>
                <br /><br />

                Sometimes it is useful to write some classes in the intermediate language, the <font color="#bf0a00">.fil </font>
                files, when you do not care about the security labels or policies and need more flexibility in the language.
                Though FabIL classes do not enforce information-flow security, they can still create Fabric objects that
                do. For more information regarding this please refer to the
                <a href="https://www.cs.cornell.edu/projects/fabric/manual/0.3.0/html/fabil.html">manual</a>.


            </div>

<!--======================================|  SET UP  |========================================-->
            <div id="setup" class="content-section">
                <h2 class="content-header">Setting Up Your Application</h2>
                Generally, Fabric applications are built using Apache Ant, which you should have installed to get
                Polyglot, Jif, and Fabric compiled and ready for use.

                <h3 class="content-subsection">Apache Ant Build Files</h3>
                The <font color="#bf0a00">build.xml</font> file, typically consists of something along the lines of:
<pre><!------------------------codeblock------------->
<code class="xml">
&lt;!--
**********************************************
    Fabric Calendar Apache Ant Build File
**********************************************
--&gt;

&lt;project name="calendar" default="build-all" basedir="."&gt;

    &lt;description&gt;
        Fabric Calendar Application
    &lt;/description&gt;

&lt;!--*****************
    Global Properties
    *****************--&gt;

    &lt;property file="etc/build.properties" /&gt;

    &lt;import file="${fabric.home}/common.xml" /&gt;
    &lt;import file="${fabric.home}/src/lib/sif/common.xml" /&gt;
    &lt;import file="${fabric.home}/src/lib/collections/common.xml" /&gt;

    &lt;dirname property="calendar.home" file="${ant.file.calendar}" /&gt;

&lt;!--****************
    Cleaning Targets
    ****************--&gt;

    &lt;target name="clean" description="remove generated files"&gt;
        &lt;delete dir="${calendar.home}/classes" /&gt;
    &lt;/target>

    &lt;target name="clobber" depends="clean" description="remove generated files and states of stores"&gt;
        &lt;delete dir="${calendar.home}/var" /&gt;
    &lt;/target>

&lt;!--*******************
    Compilation Targets
    *******************--&gt;

    &lt;target name="build-all" depends="build-calendar" /&gt;
    &lt;target name="all" depends="build-all" /&gt;

    &lt;target name="build-calendar" depends="sif" description="builds the Fabric Calendar Application" &gt;
        &lt;fabc dest="${calendar.home}/classes"&gt;
            &lt;arg value="-sourcepath" /&gt; &lt;arg value="${calendar.home}/src" /&gt;
            &lt;arg value="-cp" /&gt;         &lt;arg pathref="sif.classpath" /&gt;
            &lt;arg value="-cp" /&gt;         &lt;arg pathref="collections.classpath" /&gt;
            &lt;arg value="-cp" /&gt;         &lt;arg pathref="lib.classpath" /&gt;
            &lt;arg value="-cp" /&gt;         &lt;arg value="${calendar.home}/classes" /&gt;
            &lt;arg value="-addsigcp" /&gt;   &lt;arg pathref="sif.sigcp" /&gt;
            &lt;arg value="-trusted-providers" /&gt;

            <!--debug
            <arg value="-debugpositions"/>
            <arg value="-report" /> <arg value="frontend=1"/>
            <arg value="-report" /> <arg value="solver=5" />
            <arg value="-dump"   /> <arg value="FabricToFabilRewriter"/>
            <arg value="-dump"   /> <arg value="PrincipalCastAdder"/>
            <arg value="-report" /> <arg value="visit=2"/>
            <arg value="-report" /> <arg value="labelEnv=5" />
            <arg value="-print"  /> <arg value="RemoteCallWrapperUpdater"/>
            <arg value="-print"  /> <arg value="FieldLabelResolver"/>
            <arg value="-report" /> <arg value="error=5"/>
            <arg value="-report" /> <arg value="errors=5"/>
            <arg value="-report" /> <arg value="debug=5" />
            -->
            &lt;fileset dir="${calendar.home}/src" includes="**/*.fab" /&gt;
        &lt;/fabc&gt;

        &lt;filc dest="${calendar.home}/classes"&gt;
            &lt;arg value="-sourcepath" /&gt; &lt;arg value="${calendar.home}/src" /&gt;
            &lt;arg value="-cp" /&gt;         &lt;arg value="${calendar.home}/classes" /&gt;

            &lt;fileset dir="${calendar.home}/src" includes="**/*.fil" /&gt;
        &lt;/filc&gt;
    &lt;/target&gt;

&lt;/project&gt;
</code>
</pre><!-----------------------end codeblock--------->

                Here, the application and default build behavior is declared at the top. Then, in the section labeled "Global
                Properties" we have links to any necessary property folders or <font color="#bf0a00">common.xml</font> (build)
                files. In this example, we had to create a <font color="#bf0a00">build.properties</font> file in etc directory
                to hardcode the path to the <font color="#bf0a00">$FABRIC</font> (the fabric home directory), since Ant
                on our environment does not have <font color="#bf0a00">fabric.home</font> variable set.<br /><br />

                Afterwards, the cleaning behavior is set to remove any generated <font color="#bf0a00">*.class</font>
                files in <font color="#bf0a00">classes</font> and also generated files and states of stores in
                <font color="#bf0a00">var</font><br /><br />

                Next, in the compilation targets section, we first use <font color="#bf0a00">fabc</font> Fabric compiler,
                and grabbing any <font color="#bf0a00">.fab</font> file, we compile the respective classes into our application's
                classes directory. Then, we do the same for the <font color="#bf0a00">.fil</font> files by using the
                <font color="#bf0a00">filc</font> FabIL compiler. All necessary class paths, source paths, signatures, and
                trusted providers are passed as arguments. Though our application depends on the <font color="#bf0a00">SIF</font>
                package, the implementation of Servlet for Information Flow, and therefore uses the respective class paths,
                most applications will not require this.<br /><br />

                Another useful thing to know is that you can use <font color="#bf0a00">&lt;arg value="-h" /&gt;</font> as
                an argument to the fabc or filc compiler to see other possible argument options.

                <!-- TODO: h3 class="content-subsection">Shell Scripts</h3-->

            </div>

<!--======================================|  STORE  |========================================-->
            <div id="store" class="content-section">
                <h2 class="content-header">Store</h2>
                The storage nodes in Fabric are designed to be persistent storage for Fabric objects, and these nodes allow
                for the provision of these objects to both worker nodes and the dissemination layer. <br /><br />

                The store should group objects by similar security policies. This allows the store to easily perform the
                data shipping necessary to cache objects at any requesting node who has the associated access control labels.

                <h3 class="content-subsection">Persistence</h3>
                Storage nodes can be started with terminal commands, or with executables assuming the developer has
                created these shell scripts. Upon starting the store node, the node will first attempt to read in any
                storage files on the machine with the expected store name. If it exists, it will load the persistent data
                from there. Otherwise, it will simply create a new store from scratch. When a storage node is properly
                shutdown, without using a kill process command, then it will make sure to write all of its data in serialized
                form to its associated storage file. (Supposing the attacker has access to the store, could he read the
                store's information for himself?)

                <h3 class="content-subsection">Implementation Example</h3>
                Here, we explore a simple implementation of using a Fabric store:

<pre><!------------------------codeblock------------->
<code class="java">
// Get a reference to a store by its name
Store store = FabricWorker.getWorker().getStore("storeName");
</code>
</pre><!-----------------------end codeblock--------->

                Once we have the store, we can access objects from within the store or instantiate objects and add them
                to the store. In order to do this, consider that we want to know if we have a custom object type in our
                store already. Then, we could grab it from the root node of the store's map by using its key (a string
                of our choosing). Afterwards, we ensure that the retrieved object is of the type we wanted, and if so we
                can cast it to that object type and save it for use in the application. If it doesn't exist, or if it is
                not of the expected type, then we can create the object by doing a remote call of the custom object's
                constructor at the store; and afterwards, we add this object to the store's map with the key we choose:

<pre><!------------------------codeblock------------->
<code class="java">
if (store != null)
{
    Map rootMap = store.getRoot();
    if (rootMap != null)
    {
        Object obj = rootMap.get("customObjectMapKey");
        CustomObject custom = null;
        if (obj instance of CustomObject)
        {
            custom = (CustomObject) obj;
        }
        else
        {
            custom = new CustomObject@store();
            rootMap.put("customObjectMapKey", custom);
        }
    }
}
</code>
</pre><!-----------------------end codeblock--------->

                It is also possible to do the function shipping of a constructor requiring arguments:

<pre><!------------------------codeblock------------->
<code class="java">
custom = new CustomObject@store(arg1, arg2, arg3);
</code>
</pre><!-----------------------end codeblock--------->

                The above examples all deal with persistent objects at stores, but we can also have objects at a worker
                node's non-persistent local store, which can be accessed in the following way:

<pre><!------------------------codeblock------------->
<code class="java">
FabricWorker.getWorker().getLocalStore();
</code>
</pre><!-----------------------end codeblock--------->

                (** What is the good of having these local objects? )<br /><br />

            </div>
<!--======================================|  WORKER  |========================================-->
            <div id="worker" class="content-section">
                <h2 class="content-header">Worker</h2>



            </div>

<!--======================================|  LABELS  |========================================-->
            <div id="labels" class="content-section">
                <h2 class="content-header">Labels</h2>

                Some times Fabric's syntax can be rather hard to visually parse, especially for someone new to the language.
                Here is a breakdown of the various components in a concrete example: <br />
                <img src="imgs/FabricMethod2.svg"/><br />

                <b>Arguments:</b>   the label is passed as an argument, and currently the compiler needs to know that
                                    the label is labeled by itself, so we use a pointer. Similarly, the string argument
                                    which possibly is a date in string format also gets labeled with the pointer. <br /><br />

                <b>Method:</b>   the method call is similarly labeled with the pointer, to mean that this method requires
                                 that the caller has the same authority as the label passed to the method.<br /><br />

                <b>Return type:</b> the return type is a Date object, instantiated with the label, and likewise we label
                                    the object with a pointer to the label. <br /><br />

                <b>Exception:</b> the thrown exception could leak information, and hence we also label it with the pointer
                                  to the label. When doing this notation, the compiler requires that you use a pair of
                                  parentheses to encase the exception type and respective label.<br /><br />

                <h3 class="content-subsection">Where Clauses</h3>

            </div>

<!--======================================|  INSTANTIATION  |========================================-->
            <div id="instantiation" class="content-section">
                <h2 class="content-header">Instantiation</h2>

<pre><!------------------------codeblock------------->
<code class="java">
// TODO: how to instantiate an object with policy labels
</code>
</pre><!-----------------------end codeblock--------->

<pre><!------------------------codeblock------------->
<code class="java">
// TODO: how to instantiate an array with policy labels
</code>
</pre><!-----------------------end codeblock--------->

            </div>

<!--======================================|  THINGS TO NOTE  |========================================-->
            <div id="notes" class="content-section">
                <h2 class="content-header">Things to Note</h2>
                Fabric applications are distributed, meaning that there can often be intricate flow policies and access labels
                restricting how methods, and also objects, can interact. This is could be dependent on principals not wanting to
                reveal too much information via their program counters when methods throw exceptions, return objects, or
                instantiate new objects. Similarly, a principal may not want secrets from their objects to be revealed to
                stores that they do not trust. This means that it can be useful to think about the overall architecture
                and begin sketching access policy diagrams and flow diagrams to model what you want your system to do, and
                what you want to ensure it does not do.<br /><br />

                At the same time, the compiler likes to throw fits for reasons that may not always seem obvious. While some of
                these errors could be compiler errors or lower level errors in the language upon which Fabric is built, especially
                considering that the language is still in development and at the moment has some known bugs, this does not mean
                that all errors are bad. In fact, much of the errors are protecting you from accidentally leaking sensitive
                information that you might not have thought to protect. Some times, fixing one bug can lead to needing to
                completely revamp numerous other methods, because the previous labels were too restrictive, for example. Hence,
                it is sensible to program in small units so that you do not have to follow a slew of seemingly nonsensical
                bugs.<br /><br />

                <h3 class="content-subsection">Common Compiler Issues</h3>

                The <font color="#bf0a00">fabc</font> compiler has issues if you:

                <ul>
                    <li>Try to save your principals for your app in any other package besides <font color="#bf0a00">fabric.principals</font></li>
                </ul>

                <h3 class="content-subsection">Integrated Development Environments</h3>
                Fabric has an IDE <a href="https://github.com/apl-cornell/fabric.ide">[link]</a> which can be built if you have the following setup:
                <ul>
                    <li>Linux</li>
                    <li>Eclipse for Eclipse Committers: <a href="https://www.eclipse.org/downloads/packages/eclipse-ide-eclipse-committers/oxygen1a">[link]</a></li>
                    <li>Polyglot IDE built: <a href="https://github.com/polyglot-compiler/polyglot.ide/">[link]</a></li>
                    <li>Jif IDE built: <a href="https://github.com/apl-cornell/jif.ide">[link]</a></li>
                </ul>

                Unfortunately, the README for the Fabric IDE is not yet created, but intuition regarded how to use it in Eclipse
                can be acquired by the prerequisite Polyglot IDE's README file.<br /><br />

                Otherwise, you could use Intellij, which will not allow for as optimal IntelliSense, but you can still get
                keywords and various Fabric related symbols highlighted. First, go to <font color="#bf0a00">Preferences &gt;
                Editor &gt; File types</font>, and then create a new file type for Fabric (and FabIL). Register the <font color="#bf0a00">*.fab</font></li>
                and <font color="#bf0a00">*.fil</font></li> patterns. Then, click the pen tool under the panel containing the
                <font color="#bf0a00">Recognized File Types</font></li> and add your desired highlighted keywords in the four
                categories.<br /><br />

                <img src="imgs/intellij.png">

            </div>

<!--======================================|  CALENDAR EXAMPLE  |========================================-->
            <div id="calendar" class="content-section">
                <h2 class="content-header">Calendar Example</h2>

                A calendar application was written in Fabric's precursor language, Jif. This prior calendar, based on
                Jif's language capabilities, was not distributed. Porting the calendar to the Fabric language meant
                requiring an overhaul to the architecture. <br /><br />

                The original calendar implemented a mySQL database to achieve persistence, and setting up the database
                was a requirement for running the application. The actions for the calendar required accessing the database
                by authorized principals (calendar users). However, in the Fabric language, there is an object implemented
                with the intention of serving as a persistent database. This object, the store, follows the many new
                distributed design decisions implemented in the Fabric language. <br /><br />

                Now, instead of implementing a database, and using database calls to achieve the functionality in the
                calendar, we simply need to ensure that a storage node is running somewhere with the persistent features
                required by the calendar. In essence, this storage node acts as the top principal with the greatest label
                {&#8868;→&#8868;;&#8868;←&#8868;}, allowing the storage to perform all actions on any calendar in an
                active user session. <br /><br />

                A worker node is spun up for any individual user wanting to access the calendar. This follows the Fabric
                language premise which states that objects do not "instantiate" but rather join the overall "Fabric."
                The worker node, therefore should allow a user to either join the calendar (a future wanted capability)
                or authenticate a session if they have already joined the calendar previously. With both of these actions,
                we are able to use Fabric's idea of remote calls, accessing the storage node by invoking appropriate
                methods at the store. <br /><br />

                Adding a user is a feature that would be nice to implement, and may become another method with the least
                label that the store allows. Of course, the store will check that the username is valid and not already
                in use, especially considering the username is operating as a user-id, or key, for access to all of the
                user's objects within their calendar. At this point, unsure whether .fil classes are necessary of if
                perhaps we ought to first hard-code this functionality until
                the other portions of the calendar are implemented?<br /><br />


                <h3 class="content-subsection">Design Ideas</h3>

                From some examples, such as the Box class in MapServ, it seemed that objects were deep copied from
                one principal to the other. Perhaps for the calendar, something like this would work: <br /><br />

				<img src="imgs/calendar_1.svg"/>
				<br />

                Wondering if the following is a reasonable idea for the architecture:<br/>

                Calendar package
                <ul>
                    <li>Main - Main entrypoint for application (hopefully)</li>
                    <li>Calendar - The calendar object</li>
                    <li>Config - Configuration for the calendar</li>
                    <li>FrontPage - Front page of servlet</li>
                    <li>User - User object</li>
                    <li>Event sub package</li>
                        <ul>
                            <li>Event</li>
                            <li>CreateEvent</li>
                            <li>CreateEditEvent</li>
                            <li>FinishEditEvent</li>
                        </ul>
                    <li>Principal sub package</li>
                        <ul>
                            <li>CalendarRoot - can act on all servlet related final objects (Not sure if need)</li>
                            <li>ServletPrincipal - can act on all servlet related mutable objects</li>
                            <li>UserPrincipal - can only act on objects that UserPrincipal has CI rights</li>
                        </ul>
                    <li>Session sub package</li>
                        <ul>
                            <li>CalendarSessionState</li>
                            <li>ChangeDisplayDateAction</li>
                            <li>EditEventAction</li>
                            <li>FinishEditEventReceiver</li>
                            <li>FinishEditingEvent</li>
                            <li>SelectDisplayUser</li>
                            <li>ShowCalendar</li>
                            <li>ShowCalendarSessAction</li>
                        </ul>
                    <li>Utility sub package</li>
                        <ul>
                            <li>DateUtil</li>
                            <li>Date</li>
                            <li>Declassifier</li>
                        </ul>
                </ul>

                Login Package ("borrowed" from Travel example, but reformatted for readability concerns)


<pre><!------------------------codeblock------------->
<code class="java">
// TODO: Edit this section!
</code>
</pre><!-----------------------end codeblock--------->

<!--
                A calendar application was written in Fabric's precursor language, Jif. This prior calendar, based on
                Jif's language capabilities, was not distributed. Porting the calendar to the Fabric language meant
                requiring an overhaul to the architecture. <br /><br />

                The original calendar implemented a mySQL database to achieve persistence, and setting up the database
                was a requirement for running the application. The actions for the calendar required accessing the database
                by authorized principals (calendar users). However, in the Fabric language, there is an object implemented
                with the intention of serving as a persistent database. This object, the store, follows the many new
                distributed design decisions implemented in the Fabric language. <br /><br />

                Now, instead of implementing a database, and using database calls to achieve the functionality in the
                calendar, we simply need to ensure that a storage node is running somewhere with the persistent features
                required by the calendar. In essence, this storage node acts as the top principal with the greatest label
                {&#8868;→&#8868;;&#8868;←&#8868;}, allowing the storage to perform all actions on any calendar in an
                active user session. <br /><br />

                A worker node is spun up for any individual user wanting to access the calendar. This follows the Fabric
                language premise which states that objects do not "instantiate" but rather join the overall "Fabric."
                The worker node, therefore should allow a user to either join the calendar (a future wanted capability)
                or authenticate a session if they have already joined the calendar previously. With both of these actions,
                we are able to use Fabric's idea of remote calls, accessing the storage node by invoking appropriate
                methods at the store. <br /><br />

                Adding a user is a feature that would be nice to implement, and may become another method with the least
                label that the store allows. Of course, the store will check that the username is valid and not already
                in use, especially considering the username is operating as a user-id, or key, for access to all of the
                user's objects within their calendar. At this point, we shall first hard-code this functionality until
                the other portions of the calendar are implemented.<br /><br />

                In the case of authentication, we do not care about the latency for authentication happening over the
                wire since this would be no different if we had to do the same task via a SQL database access. At this
                point, the worker node is completely untrusted, having the least label {&#8869;→&#8869;;&#8869;←&#8869;}.
                The store allows a singular remote call to operate with this security label, namely a method which allows
                the store to receive input from the user at the given worker node. If the user provides a valid username
                and password combination, then the store will delegate the confidentiality and integrity permissions of
                that user to the active session represented by the worker node. Furthermore, it will use the Fabric's
                language feature of data shipping, and cache all objects at the worker node relating to the authenticated
                user.  <br /><br />

                <h2 class="content-subsection" content-link="Overview">A brief overview of objects within the Fabric Calendar application</h2>

                <h3>Events Objects:</h3>
                OwnerEvents and AttendeeEvents essentially have the same fields. Maybe it would be possible to allow these
                objects to cast to each other with the new policy enforced. For example, OwnerEvent can always cast to
                AttendeeEvent, but AttendeeEvent can only cast to OwnerEvent if P = uid?<br /><br />

                <strong>OwnerEvent</strong>
                Given the policy label {P→;P←}
                <ul>
                    <li>event id</li>
                    <li>owner uid</li>
                    <li>event name</li>
                    <li>event starting time</li>
                    <li>event ending time</li>
                    <li>event note</li>
                    <li>list of attendees (allowed to view but not access any field in the event)</li>
                    <li>list of viewers (only allowed to view time of event but no other field, instead see "busy")</li>
                </ul><br />

                <strong>AttendeeEvent</strong>
                Given the policy label {P→}
                <ul>
                    <li>event id</li>
                    <li>owner uid</li>
                    <li>event name</li>
                    <li>event starting time</li>
                    <li>event ending time</li>
                    <li>event note</li>
                    <li>list of attendees (allowed to view but not access any field in the event)</li>
                    <li>list of viewers (only allowed to view time of event but no other field, instead see "busy")</li>
                </ul><br />

                <strong>ViewerEvent</strong>
                <ul>
                    <li>event id</li>
                    <li>event name = "busy"</li>
                    <li>event starting time</li>
                    <li>event ending time</li>
                </ul>

                <h3>Principals:</h3>

                <strong>Store</strong><br />
                A persistent storage node representing what in the Jif implementation CalRootEP principal. This Calendar
                Root Principal has the greatest privilege {&#8868;→&#8868;;&#8868;←&#8868;} <br /><br />
                <ul>
                    <li>ownedEvents is a hash mapping uid to a hashmap of oid→OwnerEvent objects that uid owns</li>
                    <li>attendeeEvents is a hash mapping uid to a hashmap of oid→AttendeeEvent objects that uid may attend</li>
                    <li>viewerEvents is a hash mapping uid to a hashmap of oid→ViewerEvent objects that uid may view</li>
                    <li>a list of calendar users</li>
                    <li>a list of logged on users</li>
                    <li>a list of accessed objects (this becomes necessary if we are going to later let more than one
                        user edit an event)</li>
                    <li>method to add an event: <br />
                        <ul>
                            <li>append OwnedEvent to ownedEvents.get(uid).put(e.oid, e)</li>
                            <li>for each user in the list of attendees create AttendeeEvent
                                and append to attendeeEvents.get(uid).put(e.oid, e)</li>
                            <li>for each user in the list of viewers create ViewerEvent
                                and append to viewerEvents.get(uid).put(e.oid, e)</li>
                        </ul>
                    </li>
                    <li>method to edit an event: <br />
                        <ul>
                            <li>update OwnedEvent in ownedEvents.get(uid)</li>
                            <li>for each user in the list of attendees update AttendeeEvent in attendeeEvents.get(uid).get(oid),
                            and check if user is in logged on users. If so, push event to user. If push fails more than
                            x retries, assume that user left without logging off, so simply remove them from logged on
                            users list</li>
                            <li>for each user in the list of viewers update ViewerEvent in viewerEvents.get(uid).get(oid),
                            and check if user is in logged on users. If so, push event to user. If push fails more than
                            x retries, assume that user left without logging off, so simply remove them from logged on
                            users list</li>
                        </ul>
                    </li>
                    <li>method to authenticate a user: <br />
                        <ul>
                            <li>check if uid exists, if not return null</li>
                            <li>check if pw matches for uid, if so delegate rights of uid to worker and ship all objects
                            associated with this user</li>
                        </ul>
                    </li>
                    <li>method to log a user off of the system: <br />
                        <ul>
                            <li>remove user from logged on users list</li>
                            <li>later implementation could be multithreaded to check for user inactivity and automatically
                            log off users</li>
                        </ul>
                    </li>
                    <li>method give full names of active calendar users to an authenticated user: this allows user to know
                    who they can add to their events</li>
                </ul>

                <strong>Worker</strong><br />
                A temporal "session" node representing what in the Jif implementation was essentially the Userv package
                and the CalServEP principal. It starts off with the least label {&#8869;→&#8869;;&#8869;←&#8869;}, and
                has the possibility to acquire a labeling for a new user or for an existing user assuming authentication.<br /><br />

                <em>Prior to authentication:</em><br />
                <ul>
                    <li>user = bottom principal &#8869;</li>
                    <li>list of events owned = null</li>
                    <li>list of events attending = null</li>
                    <li>list of viewable events = null</li>
                    <li>method to authenticate: remote call <font color="#006400">auth(input userID, input pw)@store</font>
                    and date instantiation</li>
                    <li>method to add user: remote call <font color="#006400">add(input userID, input pw)@store</font>
                        and date instantiation</li>
                </ul>
                (I seem to remember that remote calls are protected by SSL?)<br /><br />

                <em>Upon authentication:</em><br />
                <ul>
                    <li>user = P (self)</li>
                    <li>list of events P owns</li>
                    <li>list of events P is attending</li>
                    <li>list of events P may view</li>
                    <li>method to add an event: <font color="#006400">addEvent(Event e)@store</font></li>
                    <li>method to edit an event: <font color="#006400">editEvent(Event e)@store</font></li>
                    <li>method to log off: <font color="#006400">logOff()@store</font></li>
                    <li>method to full names of other calendar users: <font color="#006400">getUsers()@store</font></li>
                </ul>

                <h3>Other Objects:</h3>
                <strong>Date</strong><br />
                This object should not require any special consideration for confidentiality policy of the assumption that
                the user can view their time and date themselves. Because we use user specific system time to instantiate
                only their calendar for a session, we are assured that no data can be leaked by this allowance. <br /><br />

                The Calendar Root Principal has some understanding of this object, but never needs to instantiate this for
                itself as it will not need to print any dates to a servlet.<br /><br />

                <strong>Servlet Related Code</strong><br />
                Because the worker only accesses data that they are allowed to read and write, the calendar that they can
                see is instantiated on these objects. This removes the need to do any downgrading in the instantiation
                and updating of the calendar client-side.<br /><br />

                <h3>This implementation requires the following considerations:</h3>
                <ol>
                    <li>
                        How will the authenticated user acquire all calendar objects that they own or have permission to
                        access or view?
                    </li>
                    <li>
                        How will the user prepare and commit new calendar event objects or edit existing events? Furthermore,
                        how will the store propagate these changes on commit, especially to any other active user?
                    </li>
                    <li>
                        (This was not existing in the prior calendar implementation, but would be fun if time permits.)
                        What issues exist during multiple user accesses to the same calendar objects, assuming we allow
                        attendees to write to the object (perhaps to leave an event)? Namely, how will the store implement
                        the transaction map so that Fabric's sense of optimistic transaction holds?
                    </li>
                    <li>
                        How does the calendar root allow a user to acquire the name of other users of the calendar? Do we
                        suppose that an authenticated user should have privilege to access this? What are any issues if we
                        further allow them to access the username which is effectively the current uid for the current
                        implementation?
                    </li>
                    <li>
                        Finally, most importantly, how will security labels properly enforce the desired purposes?
                    </li>
                </ol>    -->


                <!---TODO>
                <h3>Consideration One</h3>
                To properly account for the acquisition of a user's objects and delegation of principal rights, the store's
                overall contents must be considered.
                <TODO-----><br />

            </div>

<!--======================================|  REFERENCES  |========================================-->
            <div id="references" class="content-section">
                Currently, Fabric has been ported to a public Git Repository, to allow for more open source contribution, as
                well as allowing users of the language to submit bugs or other issues: <a href="https://github.com/apl-cornell/fabric">Fabric on Github</a>

                <h2 class="content-header">References</h2>
                <dl class="citelist">
                    <dt><a class="anchor" id="CITEREF_mobile-fabric-2012"></a>[1]</dt>
                    <dd><p class="startdd">Owen Arden, Michael&#160;D. George, Jed Liu, K.&#160;Vikram, Aslan Askarov, and Andrew&#160;C. Myers. <a href="http://www.cs.cornell.edu/andru/papers/mobile.html">Sharing mobile code securely with information flow control</a>. In <em>Proc. IEEE 2012 Symposium on Security and Privacy</em>, pages 191&ndash;205, San Francisco, CA, USA, May 2012. Software release at <a href="http://www.cs.cornell.edu/projects/fabric/">http://www.cs.cornell.edu/projects/fabric/</a>.</p>
                        <p class="enddd"></p>
                    </dd>
                    <dt><a class="anchor" id="CITEREF_oo7"></a>[2]</dt>
                    <dd><p class="startdd">Michael&#160;J. Carey, David&#160;J. DeWitt, and Jeffrey&#160;F. Naughton. The OO7 benchmark. In <em>Proc. ACM SIGMOD 1993 International Conference on Management of Data</em>, pages 12&ndash;21, Washington, DC, USA, May 1993.</p>
                        <p class="enddd"></p>
                    </dd>
                    <dt><a class="anchor" id="CITEREF_sif2007"></a>[3]</dt>
                    <dd><p class="startdd">Stephen Chong, K.&#160;Vikram, and Andrew&#160;C. Myers. <a href="http://www.cs.cornell.edu/andru/papers/sif.pdf">SIF: Enforcing confidentiality and integrity in web applications</a>. In <em>Proc. 16th USENIX Security Symposium</em>, pages 1&ndash;16, Boston, MA, USA, August 2007. See <a href="http://www.cs.cornell.edu/jif/sif/">http://www.cs.cornell.edu/jif/sif/</a>.</p>
                        <p class="enddd"></p>
                    </dd>
                    <dt><a class="anchor" id="CITEREF_fabric2009"></a>[4]</dt>
                    <dd><p class="startdd">Jed Liu, Michael&#160;D. George, K.&#160;Vikram, Xin Qi, Lucas Waye, and Andrew&#160;C. Myers. <a href="http://www.cs.cornell.edu/andru/papers/fabric-sosp09.html">Fabric: A platform for secure distributed computation and storage</a>. In <em>Proc. 22nd ACM Symposium on Operating System Principles (SOSP)</em>, pages 321&ndash;334, Big Sky, MT, USA, October 2009. Software release at <a href="http://www.cs.cornell.edu/projects/fabric/">http://www.cs.cornell.edu/projects/fabric/</a>.</p>
                        <p class="enddd"></p>
                    </dd>
                    <dt><a class="anchor" id="CITEREF_jif-popl1999"></a>[5]</dt>
                    <dd><p class="startdd">Andrew&#160;C. Myers. <a href="http://www.cs.cornell.edu/andru/papers/popl99/myers-popl99.ps.gz">JFlow: Practical mostly-static information flow control</a>. pages 228&ndash;241, San Antonio, TX, USA, January 1999. Software release at <a href="http://www.cs.cornell.edu/jif/">http://www.cs.cornell.edu/jif/</a>.</p>
                        <p class="enddd"></p>
                    </dd>
                </dl>
            </div>
        </div>
	</div>
</div>
</body>
</html>

<!--example codeblock
<pre><!------------------------codeblock------------------------------------------------------><!--
<code class="java">
public class FileOutputStream[label L] extends OutputStream[L]
{
    private static int __JIF_SIG_OF_JAVA_CLASS$20030619 = 0;

    private FileOutputStream() { }
    public native void write{L}(int{L} b) throws (IOException{L});
    private native void writeBytes{L}(byte{L}[]{L} b, int{L} off, int{L} len) throws (IOException{L});
    public native void write{L}(byte{L}[]{L} b) throws (IOException);
    public native void write{L}(byte{L}[]{L} b, int{L} off, int{L} len) throws (IOException{L});
    public native void close{L}() throws (IOException{L});
    public final native FileDescriptor{L} getFD()  throws (IOException{L});
}
</code>
</pre><!------------------------end codeblock--------------------------------------------------->